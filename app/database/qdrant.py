from app.config.config import Config
from app.config.config_instance import ConfigInstance
from app.exceptions.exceptions import DatabaseConnectionError, DatabaseOffline, InvalidQuery
from app.interfaces.vector_database_interface import VectorDatabaseInterface
from qdrant_client import QdrantClient, models
from qdrant_client.models import VectorParams, Distance, PointStruct

from app.logger.logger import Logger, LoggerInstance
from app.models.collection import CollectionDto
from app.models.field import Field
from app.models.file import FileBatch

from qdrant_client.models import Filter, FieldCondition

from app.models.search import Search



class Qdrant(VectorDatabaseInterface):
    client = None
    def __init__(self, config: Config, logger: Logger):
        # inject config here
        self.config = config
        self.connected = False
        self.logger = logger
        self.attempts = 0
        self.start()
        self.embedding_default_field_name = "embedding"

    def start(self):
        max_attempts = int(self.config.get("QDRANT_ATTEMPTS"))
        while self.attempts <= max_attempts:
            self.logger.info(
                f"[QDRANT] ATTEMPT {self.attempts} to connect to Qdrant at "
                f"{self.config.get('QDRANT_HOST')}:{self.config.get('QDRANT_PORT')}, DB:{self.config.get('QDRANT_DB_NAME')}"
            )
            try:
                host=str(self.config.get('QDRANT_HOST'))
                port=self.config.get('QDRANT_PORT')
                api_key=self.config.get('QDRANT_API_KEY') or ''
                print(f"host: {host}, port: {port}")
                self.client = QdrantClient(host=host, port=port, api_key=api_key)
                self.connected = True
                self.logger.info(f"CONNECTION ESTABLISHED: {self.test_connection()}")
                self.logger.info(f"[DB] LISTADO COLECCIONES: {self.client.get_collections()}")
                break
            except Exception as e:
                if self.attempts == max_attempts:
                    raise DatabaseConnectionError()
                self.connected = False
                self.logger.error(str(e))
                self.logger.warning("[QDRANT] CONNECTION WASN'T ESTABLISHED CORRECTLY.")
                self.attempts += 1

    def online(self):
        """
          Verify that database connection is online.
          Otherwise, DatabaseOffline exception is raised.
        """
        if not self.client:
            self.connected = False
            self.logger.info("[Qdrant] OFFLINE")
            try:
                self.start()
            except Exception as e:
                self.logger.error(str(e))
                raise DatabaseOffline()
        return self.connected

    def test_connection(self):
        return self.online()
    
    ####### autogenerated methods #######
    def change_database (self, db_name: str):
        self.online()
        return self.client.change_db(db_name)

    def check_if_collection_exists (self, collection_name: str):
        self.online()
        return self.client.check_collection(collection_name)
    
    def create_collection_batch (self, collection_name: str, vectors: list[list[float]]):
        self.online()
        return self.client.create_collection(collection_name, vectors)
    
    def create_collection_schema (self, collection_schema: CollectionDto):
        try:            
            self.online()
            distance_param = None
            if collection_schema.distance is None or collection_schema.distance == "":
                distance_param = Distance.COSINE
            else:
                distance_param = collection_schema.distance
            result = self.client.recreate_collection(
            collection_name=collection_schema.name,
            vectors_config=VectorParams(distance=distance_param),
            )
            self.logger.info(f"Coleccion creada: {collection_schema.name}")
            return result
        except Exception as e:
            self.logger.error(str(e))
            raise InvalidQuery()

    def create_collection_with_schema (self, collection_name: str, schema: dict):
        self.online()
        return self.client.create_collection(collection_name, schema)
    
    def delete_collection (self, collection_name: str):
        self.online()
        return self.client.delete_collection(collection_name)
    
    def dynamic_data_structure(self, schema):
        fields = schema.fields
        data = {}
        for field in fields:
            data[field.name] = []
        return data

    async def insert_data(self, collection_name: str, files: FileBatch):
        try:
            # Verificar si la colección existe, si no existe crearla
            if not self.check_if_collection_exists(collection_name):
                self.logger.info(f"La colección '{collection_name}' no existe. Creando colección...")
                
                # Crear una configuración básica para la colección
                # Asumiendo que los embeddings tienen una dimensión estándar (puedes ajustar según tus necesidades)
                vector_size = len(files.file_chunks[0].embedding) if files.file_chunks and files.file_chunks[0].embedding else 1536
                
                self.client.recreate_collection(
                    collection_name=collection_name,
                    vectors_config=VectorParams(
                        size=vector_size,
                        distance=Distance.COSINE
                    )
                )
                self.logger.info(f"Colección '{collection_name}' creada exitosamente.")
            
            point_structs = []
            for index, file_chunk in enumerate(files.file_chunks):
                # Agregamos el contenido a los metadatos
                file_chunk.metadata['content'] = file_chunk.content
    
                # sacamos valores del chunk
                embedding = None
                metadata = None
                embedding = file_chunk.embedding
                metadata = file_chunk.metadata
    
                points=PointStruct(id=index, vector=embedding, payload=metadata)
                point_structs.append(points)
    
            self.client.upsert(
                collection_name=collection_name,
                points=point_structs
            )
            self.logger.info(f"Proceso de inserción de datos en {collection_name} completado.")
    
        except Exception as e:
            print("error insert_data:", str(e))
            self.logger.error(str(e))
            raise InvalidQuery()
    
    def list_collections (self):
        self.online()
        return self.client.get_collections()
    
    def map_data_type (self, field_type: str):
        self.online()
        return self.client.map_data_type(field_type)

    def prepare_data(self, files: FileBatch, dynamic_data: dict[str, list], **kwargs):
        # No usado actualmente
        return files.file_chunks
    
    def see_connection(self):
        return self.vector_database.test_connection()

    def list_collections(self) -> list[str]:
        return self.vector_database.list_collections()

    def search_text(self, search: Search) -> list[str]:
        if search.filter_property is None or search.filter_property == "":
            return self.search_text_no_filter(search)
        else:
            return self.search_text_filter(search)

    def search_text_filter(self, search: Search) -> list[str]:
        try:
            hits = self.client.search(
            collection_name=search.collection_name,
            query_vector=search.search_embedding,
            query_filter=Filter(
                must=[ 
                        FieldCondition(
                        key=search.filter_property,  # Condition based on values of `column` field.
                        match={"value":search.filter_value}
                        )
                ]
            ),
            limit=search.top_k,  # Return number of closest points
            with_vectors=True,
            )
            return hits
    
        except Exception as e:
            self.logger.error(str(e))
            raise InvalidQuery()

    def search_text_no_filter(self, search: Search) -> list[str]:
        try:
            hits = self.client.search(
            collection_name=search.collection_name,
            query_vector=search.search_embedding,
            limit=search.top_k,
            with_vectors=True,
            )
            return hits
        except Exception as e:
            self.logger.error(str(e))
            return []

    async def save(self, file_batch: FileBatch, collection_name: str):
        return await self.insert_data(collection_name, file_batch)

    def delete(self, collection_name, point_id):
        return self.client.delete(collection_name=collection_name,
            points_selector=models.PointIdsList(
                points=point_id,
            ),
        )
    
    def create_field_schema(self, field: Field):
        return self.vector_database.create_field_schema(field)

    def check_if_collection_exists(self, collection_name: str):
        return self.client.collection_exists(collection_name)



    async def delete_data_collection(self, collection: CollectionDto):
        self.client.delete(
                collection_name=collection.name,
                points_selector=models.FilterSelector(
                    filter=models.Filter(
                    must=[]
                )
        )
    )


# Singleton instance
QdrantInstance = Qdrant(config=ConfigInstance, logger=LoggerInstance)
